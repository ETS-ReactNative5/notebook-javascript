---
title: 执行上下文
order: 2
---

## 调用栈

JavaScript 代码有两种类型：

1. **全局代码**，在所有函数外部定义；
2. **函数代码**，位于函数内部。JavaScript 引擎执行代码时，每一条语句都处于特定的执行上下文中。

既然具有两种类型的代码，那么就有两种执行上下文：全局执行上下文和函数执行上下文。二者最重要的差别是：全局执行上下文只有一个，当 JavaScript 程序开始执行时就已经创建了全局上下文；而函数执行上下文是在每次调用函数时，就会创建一个新的。

JavaScript 基于单线程的执行模型：在某个特定的时刻只能执行特定的代码。一旦发生函数调用，当前的执行上下文必须停止执行，并创建新的函数执行上下文来执行函数。当函数执行完成后，将函数执行上下文销毁，并重新回到发生调用时的执行上下文中。所以需要跟踪执行上下文——正在执行的上下文以及正在等待的上下文。最简单的跟踪方法是使用执行上下文栈（或称为调用栈）。

```js
function skulk(ninja) {
  report(ninja + 'skulking');
}
function report(message) {
  console.log(message);
}

skulk('Kuma');
skulk('Yoshi');
```

执行上下文的行为如下：

1. 每个 JavaScript 程序只创建一个全局执行上下文，并从全局执行上下文开始执行（在单页应用中每个页面只有一个全局执行上下文）。当执行全局代码时，全局执行上下文处于活跃状态。
2. 首先在全局代码中定义两个函数：skulk 和 report，然后调用 skulk("Kuma")。由于在同一个特定时刻只能执行特定代码，所以 JavaScript 引擎停止执行全局代码，开始执行带有 Kuma 参数的 skulk 函数。创建新的函数执行上下文，并置入执行上下文栈的顶部。
3. skulk 函数进而调用 report 函数。又一次因为在同一个特定时刻只能执行特定代码，所以，暂停 skulk 执行上下文，创建新的 Kuma 作为参数的 report 函数的执行上下文，并置入执行上下文栈的顶部。
4. report 通过内置函数 console.log 打印出消息后，report 函数执行完成，代码又回到了 skulk 函数。report 执行上下文从执行上下文栈顶部弹出，skulk 函数执行上下文重新激活，skulk 函数继续执行。
5. skulk 函数执行完成后也发生类似的事情：skulk 函数执行上下文从栈顶端弹出，重新激活一直在等待的全局执行上下文并恢复执行。JavaScript 的全局代码恢复执行。

## 词法环境

**词法环境（lexicalenvironment）** 是 JavaScript 引擎内部用来跟踪标识符与特定变量之间的映射关系。

通常来说，词法环境与特定的 JavaScript 代码结构关联，既可以是一
个函数、一段代码片段，也可以是 try-catch 语句。这些代码结构（函
数、代码片段、try-catch）可以具有独立的标识符映射表。
